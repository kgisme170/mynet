启动集群:
1. 启动Master
$SPARK_HOME/sbin/start-master.sh

2. 启动工作节点
$SPARK_HOME/sbin/spark-class org.apache.spark.deploy.worker.Worker<Spark-Master> &

这个Spark-Master就是Spark URL，在用户界面顶端出现的Spark Master at:

3. 使用jdbc
spark-submit --driver-class-path /home/a/.m2/repository/mysql/mysql-connector-java/5.1.39/mysql-connector-java-5.1.39.jar --jars target/myspark-1-1.0-SNAPSHOT.jar --class jdbcMysql target/myspark-1-1.0-SNAPSHOT.jar

4. useKafka
5. dubbo
---------------------
If we use Fork/join framework, when to call "ThreadLocal.remove()" function?

---------------------
unicode/encode/decode/char/CharSequence

---------------------
覆盖了equals就必须重写hashCode，如果不重写hashCode方法呢？
hashCode必须和equals返回一致
---------------------
class什么时候该继承Comparator，什么时候该继承Comparator

---------------------

Java: Why is interface's super class able to call interface function?

I've got a code snippet from internet:

"IMy" interface with default function, MyImpl overrides f3() and the way to IMy::f3() inside MyImpl is "IMy.super.f3()":

    interface IMy {
        default void f1() {}
        default void f3() {}
        static void sf() {
            System.out.println("f1, f2");
        }
    }

    class MyImpl implements IMy {
        @Override
        public void f3() {
            f1();
            IMy.super.f3();//works!
            super.f3(); // doesn't compile!
            System.out.println("f3");
        }
    }

It works,but I'm just curious: f3() is a function of "IMy", but what does "IMy.super" actually mean? I tried to change it to "super.f3()", it doesn't compile.

I expected that MyImpl.super = IMy, thus should be able to call IMy.f3(), but the actual result was the contrary.

So how to understand this IMy.super, would you help to explain?
----------------------
Java Proxy.newProxyInstance() throws type cast exception?

My following code tries to create a proxy-ed object that I expected to print "before" before calling "say()":

    class Person2 {
        private String name;
        public Person2(String name) {
            this.name = name;
        }
        public void say() {
            System.out.println("Person:" + name);
        }
    }
    class MyHandler implements InvocationHandler {
        private Object object;
        public MyHandler(Object o) {
            object = o;
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //
            System.out.println("before");
            return method.invoke(object, args);
        }
    }
    public class TestProxy {
        public static void main(String [] args) {
            Person2 p = new Person2("myName");
            InvocationHandler invocationHandler = new MyHandler(p);
            Person2 obj = (Person2) Proxy.newProxyInstance(
                    p.getClass().getClassLoader(),
                    p.getClass().getInterfaces(),
                    invocationHandler);
            obj.say();
        }
    }

But in fact it will throw out an exception:

    Exception in thread "main" java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to Person2
	at TestProxy.main

So where did I get wrong and how to fix it?
----------------------

Java logger config file doesn't take effect.

I've got a simple java program:

    public class UseLog {
        public static final Logger logger = Logger.getLogger("UseLog");
        public static void main(String[] args) {
            logger.info("my4");
        }
    }

And a "myConfig.txt" file:

    .level=WARNING
    UseLog.level=WARNING

I compile and run it with command line:

    java UseLog -Djava.util.logging.config.file=myConfig.txt

I expected that it should print nothing, but in fact:

    Jan 05, 2019 10:46:13 下午 UseLog main
    INFO: my4

So seems that my config file is not effective for my program. Where did I get wrong and how to fix?
-----------------------

What's the difference between java function's vararg array and normal array?

There're 2 kinds of function declarations:

    void f(String ... s) {
        System.out.println(s.length);
    }
    void g(String [] s){
        System.out.println(s.length);
    }

Both are ok, I would guess "f()" is only a form of syntax suger of g()?

When using f(), java compile will still create an internal array of s, right or wrong? I checked the class file inside Intellij, seems the disassembly code for f() is still String... not String[]

Would you kindly help to clarify? Thanks a lot.
-----------------------

How to define a java generic function without return type(void)?

I wish to do this:

    class My {
        void <T> f(T arg){...}
    }

Is it possible to do so? Seems generic programming samples all seem to have a T type as return value. But void function should also be ok right?

The code above doesn't compile actually. So how to fulfill my requirement?
Thanks a lot.
------------------------

Does oracle jdk really support thread priority?

The book <<Java core programming>> said oracle jdk treat all threads as same priority. So is there any way to write a quite sample to verify this?
Thanks a lot.
------------------------

Why some java exceptions are not forced to be handled?

I'm new to java, at first I thought all exceptions are forced to be handled, thus java program is exception free, like this:

    try {
        FileOutputStream fos = new FileOutputStream(new File(""));
    } catch (FileNotFoundException e) { // If not this "catch", program fails to compile.

    }

But I soon learned that some exceptions are not forced to be handled like:

    int i = Integer.parseInt("ff");

It throws out an exception:

    java.lang.NumberFormatException

I'm just curious: if exception is possible, why not force to try and catch exception like IO stream? Why some exceptions are not forced to "try/catch"?

Thanks a lot.
-------------------------
散列集，装载因子
-------------------------

How to guarantee thread safe for 2 sequential statements in java?

Usually in java we have simulated bank account transfer functions like below, using ReentrantLock.newCondition():

    class Bank {
        private Lock bankLock = new ReentrantLock();
        private Condition sufficientFunds = bankLock.newCondition();
        private final double[] accounts;

        public Bank(int n, double initialBalance) {
            accounts = new double[n];
            Arrays.fill(accounts, initialBalance);
        }

        public void transfer(int from, int to, double amount) throws InterruptedException {
            bankLock.lock();
            try {
                while(accounts[from] < amount) {
                    sufficientFunds.await();
                }
                System.out.println(Thread.currentThread());
                accounts[from] -= amount;//risky
                // What if interrupted here ??????
                accounts[to] += amount;  //risky
                sufficientFunds.signalAll();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                bankLock.unlock();
            }
        }


It looks OK, because this is the usual case of using condition for thread synchronization, the lock will always be "unlocked" when thread interrupted.

But in case this thread is interrupted in the place between

    accounts[from] -= amount;//risky

and

    accounts[to] += amount;  //risky

Then the total bank amount will not be balances at all. And I think declaring "accounts" to be atomic array doesn't solve the problem either. I think the problem lies in that, I should make "+ money" and "- money" inside a transaction, either both success, or should rollback.

So it there any convenient way in java concurrent library to achieve this (transaction) ? Or this needs some special design, and how to implement it?

Thanks a lot.

------------------------
Java Condition throws out IllegalMonitorStateException.

I'm testing the await function of Condition, in main thread, I created a sub-thread which sleeps a while and wakes up main thread, the main thread will use a while loop to check if condition is met:

    public class TestLockWithCondition {
        static boolean flag = true;

        public static void main(String[] args) {
            Lock bankLock = new ReentrantLock();
            Condition sufficientFunds = bankLock.newCondition();
            try {
                Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        try {
                            Thread.sleep(500);
                            System.out.println("signal main thread");
                            sufficientFunds.signalAll();
                            Thread.sleep(300);
                            flag = false;
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                };
                Thread t = new Thread(runnable);
                t.start();

                bankLock.lock();
                try {
                    while (flag) {
                        System.out.println("main enters while");
                        sufficientFunds.await();
                        System.out.println("main await ends");
                    }
                    System.out.println("main woke up" + Thread.currentThread());
                    sufficientFunds.signalAll();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    bankLock.unlock();
                }

                System.out.println("end");
                t.join();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                System.out.println("finally unlock");
                bankLock.unlock();
            }
        }
    }


When I run it, it prints:

    main enters while
    signal main thread
    java.lang.IllegalMonitorStateException
	    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.signalAll(AbstractQueuedSynchronizer.java:1954)
	    at TestLockWithCondition$1.run(TestLockWithCondition.java:21)
	    at java.lang.Thread.run(Thread.java:745)

And the program hangs. I wish to know:

(1) Why my program throws exception and then hangs

(2) How to fix it?

--------------------

            //rowSet.setTableName("myTable");
            // rowSet.deleteRow()
            WebRowSet derby?
--------------------

Where is java's system preference stored under mac? Couldn't find it.

I've got following code snippet:

    public void setPreference() throws Exception {
        prefs = Preferences.userRoot().node(this.getClass().getName());
        String ID1 = "Test1";
        String ID2 = "Test2";
        String ID3 = "Test3";

        System.out.println(prefs.getBoolean(ID1, true));
        System.out.println(prefs.get(ID2, "Hello World"));
        System.out.println(prefs.getInt(ID3, 50));

        prefs.putBoolean(ID1, false);
        prefs.put(ID2, "Hello Europa");
        prefs.putInt(ID3, 45);
        prefs.remove(ID1);
        prefs.flush();
    }

    public static void main(String[] args) throws Exception {
        PreferenceTest test = new PreferenceTest();
        test.setPreference();
    }

Yes, it runs well, restore system preference before I set them. I google-ed and it said that on mac, the preference is stored under $HOME as an hiden file. But I "ls -al ~" but didn't find a new hidden file. So what's its name and what's the content of it?

Thanks a lot.

--------------------
