启动集群:
1. 启动Master
$SPARK_HOME/sbin/start-master.sh

2. 启动工作节点
$SPARK_HOME/sbin/spark-class org.apache.spark.deploy.worker.Worker<Spark-Master> &

这个Spark-Master就是Spark URL，在用户界面顶端出现的Spark Master at:

3. 使用jdbc
spark-submit --driver-class-path /home/a/.m2/repository/mysql/mysql-connector-java/5.1.39/mysql-connector-java-5.1.39.jar --jars target/myspark-1-1.0-SNAPSHOT.jar --class jdbcMysql target/myspark-1-1.0-SNAPSHOT.jar

4. useKafka
5. dubbo
---------------------
If we use Fork/join framework, when to call "ThreadLocal.remove()" function?

---------------------
unicode/encode/decode/char/CharSequence

---------------------
覆盖了equals就必须重写hashCode，如果不重写hashCode方法呢？
hashCode必须和equals返回一致
---------------------
class什么时候该继承Comparator，什么时候该继承Comparator

---------------------

Java: How to call interfaces' default function while overriding?

I've got a code snippet as below: I have "IMy" interface with default function, in MyImpl class I override f3() and I wish to call IMy::f3() inside it:

    interface IMy {
        default void f1() {}
        default void f3() {}
        static void sf() {
            System.out.println("f1, f2");
        }
    }

    class MyImpl implements IMy {
        @Override
        public void f3() {
            f1();
            MyImpl.super.f3();//compilation error!
            System.out.println("f3");
        }
    }

There is compilation error, how to fix this? Thanks a lot.
----------------------
Java Proxy.newProxyInstance() throws type cast exception?

My following code tries to create a proxy-ed object that I expected to print "before" before calling "say()":

    class Person2 {
        private String name;
        public Person2(String name) {
            this.name = name;
        }
        public void say() {
            System.out.println("Person:" + name);
        }
    }
    class MyHandler implements InvocationHandler {
        private Object object;
        public MyHandler(Object o) {
            object = o;
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //
            System.out.println("before");
            return method.invoke(object, args);
        }
    }
    public class TestProxy {
        public static void main(String [] args) {
            Person2 p = new Person2("myName");
            InvocationHandler invocationHandler = new MyHandler(p);
            Person2 obj = (Person2) Proxy.newProxyInstance(
                    p.getClass().getClassLoader(),
                    p.getClass().getInterfaces(),
                    invocationHandler);
            obj.say();
        }
    }

But in fact it will throw out an exception:

    Exception in thread "main" java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to Person2
	at TestProxy.main

So where did I get wrong and how to fix it?
