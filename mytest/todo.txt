启动集群:
1. 启动Master
$SPARK_HOME/sbin/start-master.sh

2. 启动工作节点
$SPARK_HOME/sbin/spark-class org.apache.spark.deploy.worker.Worker<Spark-Master> &

这个Spark-Master就是Spark URL，在用户界面顶端出现的Spark Master at:

3. 使用jdbc
spark-submit --driver-class-path /home/a/.m2/repository/mysql/mysql-connector-java/5.1.39/mysql-connector-java-5.1.39.jar --jars target/myspark-1-1.0-SNAPSHOT.jar --class jdbcMysql target/myspark-1-1.0-SNAPSHOT.jar

4. useKafka
5. dubbo
---------------------
If we use Fork/join framework, when to call "ThreadLocal.remove()" function?

---------------------
unicode/encode/decode/char/CharSequence

---------------------
覆盖了equals就必须重写hashCode，如果不重写hashCode方法呢？
hashCode必须和equals返回一致
---------------------
class什么时候该继承Comparator，什么时候该继承Comparator

---------------------

Java: How to call interfaces' default function while overriding?

I've got a code snippet as below: I have "IMy" interface with default function, in MyImpl class I override f3() and I wish to call IMy::f3() inside it:

    interface IMy {
        default void f1() {}
        default void f3() {}
        static void sf() {
            System.out.println("f1, f2");
        }
    }

    class MyImpl implements IMy {
        @Override
        public void f3() {
            f1();
            MyImpl.super.f3();//compilation error!
            System.out.println("f3");
        }
    }

There is compilation error, how to fix this? Thanks a lot.
----------------------
Java Proxy.newProxyInstance() throws type cast exception?

My following code tries to create a proxy-ed object that I expected to print "before" before calling "say()":

    class Person2 {
        private String name;
        public Person2(String name) {
            this.name = name;
        }
        public void say() {
            System.out.println("Person:" + name);
        }
    }
    class MyHandler implements InvocationHandler {
        private Object object;
        public MyHandler(Object o) {
            object = o;
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //
            System.out.println("before");
            return method.invoke(object, args);
        }
    }
    public class TestProxy {
        public static void main(String [] args) {
            Person2 p = new Person2("myName");
            InvocationHandler invocationHandler = new MyHandler(p);
            Person2 obj = (Person2) Proxy.newProxyInstance(
                    p.getClass().getClassLoader(),
                    p.getClass().getInterfaces(),
                    invocationHandler);
            obj.say();
        }
    }

But in fact it will throw out an exception:

    Exception in thread "main" java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to Person2
	at TestProxy.main

So where did I get wrong and how to fix it?
----------------------

Java logger config file doesn't take effect.

I've got a simple java program:

    public class UseLog {
        public static final Logger logger = Logger.getLogger("UseLog");
        public static void main(String[] args) {
            logger.info("my4");
        }
    }

And a "myConfig.txt" file:

    .level=WARNING
    UseLog.level=WARNING

I compile and run it with command line:

    java UseLog -Djava.util.logging.config.file=myConfig.txt

I expected that it should print nothing, but in fact:

    Jan 05, 2019 10:46:13 下午 UseLog main
    INFO: my4

So seems that my config file is not effective for my program. Where did I get wrong and how to fix?
-----------------------

What's the difference between java function's vararg array and normal array?

There're 2 kinds of function declarations:

    void f(String ... s) {
        System.out.println(s.length);
    }
    void g(String [] s){
        System.out.println(s.length);
    }

Both are ok, I would guess "f()" is only a form of syntax suger of g()?

When using f(), java compile will still create an internal array of s, right or wrong? I checked the class file inside Intellij, seems the disassembly code for f() is still String... not String[]

Would you kindly help to clarify? Thanks a lot.
-----------------------

How to define a java generic function without return type(void)?

I wish to do this:

    class My {
        void <T> f(T arg){...}
    }

Is it possible to do so? Seems generic programming samples all seem to have a T type as return value. But void function should also be ok right?

The code above doesn't compile actually. So how to fulfill my requirement?
Thanks a lot.
------------------------

Does oracle jdk really support thread priority?

The book <<Java core programming>> said oracle jdk treat all threads as same priority. So is there any way to write a quite sample to verify this?
Thanks a lot.
------------------------

Why some java exceptions are not forced to be handled?

I'm new to java, at first I thought all exceptions are forced to be handled, thus java program is exception free, like this:

    try {
        FileOutputStream fos = new FileOutputStream(new File(""));
    } catch (FileNotFoundException e) { // If not this "catch", program fails to compile.

    }

But I soon learned that some exceptions are not forced to be handled like:

    int i = Integer.parseInt("ff");

It throws out an exception:

    java.lang.NumberFormatException

I'm just curious: if exception is possible, why not force to try and catch exception like IO stream? Why some exceptions are not forced to "try/catch"?

Thanks a lot.
-------------------------
散列集，装载因子
